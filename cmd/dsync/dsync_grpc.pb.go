// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package main

import (
	context "context"
	empty "github.com/golang/protobuf/ptypes/empty"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// ReplicaClient is the client API for Replica service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ReplicaClient interface {
	DoOffer(ctx context.Context, opts ...grpc.CallOption) (Replica_DoOfferClient, error)
	DoBlobs(ctx context.Context, opts ...grpc.CallOption) (Replica_DoBlobsClient, error)
	DoAnchors(ctx context.Context, opts ...grpc.CallOption) (Replica_DoAnchorsClient, error)
}

type replicaClient struct {
	cc grpc.ClientConnInterface
}

func NewReplicaClient(cc grpc.ClientConnInterface) ReplicaClient {
	return &replicaClient{cc}
}

func (c *replicaClient) DoOffer(ctx context.Context, opts ...grpc.CallOption) (Replica_DoOfferClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Replica_serviceDesc.Streams[0], "/main.Replica/DoOffer", opts...)
	if err != nil {
		return nil, err
	}
	x := &replicaDoOfferClient{stream}
	return x, nil
}

type Replica_DoOfferClient interface {
	Send(*Bytes) error
	Recv() (*Bytes, error)
	grpc.ClientStream
}

type replicaDoOfferClient struct {
	grpc.ClientStream
}

func (x *replicaDoOfferClient) Send(m *Bytes) error {
	return x.ClientStream.SendMsg(m)
}

func (x *replicaDoOfferClient) Recv() (*Bytes, error) {
	m := new(Bytes)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *replicaClient) DoBlobs(ctx context.Context, opts ...grpc.CallOption) (Replica_DoBlobsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Replica_serviceDesc.Streams[1], "/main.Replica/DoBlobs", opts...)
	if err != nil {
		return nil, err
	}
	x := &replicaDoBlobsClient{stream}
	return x, nil
}

type Replica_DoBlobsClient interface {
	Send(*Bytes) error
	CloseAndRecv() (*empty.Empty, error)
	grpc.ClientStream
}

type replicaDoBlobsClient struct {
	grpc.ClientStream
}

func (x *replicaDoBlobsClient) Send(m *Bytes) error {
	return x.ClientStream.SendMsg(m)
}

func (x *replicaDoBlobsClient) CloseAndRecv() (*empty.Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(empty.Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *replicaClient) DoAnchors(ctx context.Context, opts ...grpc.CallOption) (Replica_DoAnchorsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Replica_serviceDesc.Streams[2], "/main.Replica/DoAnchors", opts...)
	if err != nil {
		return nil, err
	}
	x := &replicaDoAnchorsClient{stream}
	return x, nil
}

type Replica_DoAnchorsClient interface {
	Send(*AnchorTuple) error
	CloseAndRecv() (*empty.Empty, error)
	grpc.ClientStream
}

type replicaDoAnchorsClient struct {
	grpc.ClientStream
}

func (x *replicaDoAnchorsClient) Send(m *AnchorTuple) error {
	return x.ClientStream.SendMsg(m)
}

func (x *replicaDoAnchorsClient) CloseAndRecv() (*empty.Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(empty.Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ReplicaServer is the server API for Replica service.
// All implementations must embed UnimplementedReplicaServer
// for forward compatibility
type ReplicaServer interface {
	DoOffer(Replica_DoOfferServer) error
	DoBlobs(Replica_DoBlobsServer) error
	DoAnchors(Replica_DoAnchorsServer) error
	mustEmbedUnimplementedReplicaServer()
}

// UnimplementedReplicaServer must be embedded to have forward compatible implementations.
type UnimplementedReplicaServer struct {
}

func (*UnimplementedReplicaServer) DoOffer(Replica_DoOfferServer) error {
	return status.Errorf(codes.Unimplemented, "method DoOffer not implemented")
}
func (*UnimplementedReplicaServer) DoBlobs(Replica_DoBlobsServer) error {
	return status.Errorf(codes.Unimplemented, "method DoBlobs not implemented")
}
func (*UnimplementedReplicaServer) DoAnchors(Replica_DoAnchorsServer) error {
	return status.Errorf(codes.Unimplemented, "method DoAnchors not implemented")
}
func (*UnimplementedReplicaServer) mustEmbedUnimplementedReplicaServer() {}

func RegisterReplicaServer(s *grpc.Server, srv ReplicaServer) {
	s.RegisterService(&_Replica_serviceDesc, srv)
}

func _Replica_DoOffer_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ReplicaServer).DoOffer(&replicaDoOfferServer{stream})
}

type Replica_DoOfferServer interface {
	Send(*Bytes) error
	Recv() (*Bytes, error)
	grpc.ServerStream
}

type replicaDoOfferServer struct {
	grpc.ServerStream
}

func (x *replicaDoOfferServer) Send(m *Bytes) error {
	return x.ServerStream.SendMsg(m)
}

func (x *replicaDoOfferServer) Recv() (*Bytes, error) {
	m := new(Bytes)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Replica_DoBlobs_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ReplicaServer).DoBlobs(&replicaDoBlobsServer{stream})
}

type Replica_DoBlobsServer interface {
	SendAndClose(*empty.Empty) error
	Recv() (*Bytes, error)
	grpc.ServerStream
}

type replicaDoBlobsServer struct {
	grpc.ServerStream
}

func (x *replicaDoBlobsServer) SendAndClose(m *empty.Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *replicaDoBlobsServer) Recv() (*Bytes, error) {
	m := new(Bytes)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Replica_DoAnchors_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ReplicaServer).DoAnchors(&replicaDoAnchorsServer{stream})
}

type Replica_DoAnchorsServer interface {
	SendAndClose(*empty.Empty) error
	Recv() (*AnchorTuple, error)
	grpc.ServerStream
}

type replicaDoAnchorsServer struct {
	grpc.ServerStream
}

func (x *replicaDoAnchorsServer) SendAndClose(m *empty.Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *replicaDoAnchorsServer) Recv() (*AnchorTuple, error) {
	m := new(AnchorTuple)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Replica_serviceDesc = grpc.ServiceDesc{
	ServiceName: "main.Replica",
	HandlerType: (*ReplicaServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "DoOffer",
			Handler:       _Replica_DoOffer_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "DoBlobs",
			Handler:       _Replica_DoBlobs_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "DoAnchors",
			Handler:       _Replica_DoAnchors_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "dsync.proto",
}
